from __future__ import print_function
import os, sys
import time

from collections import OrderedDict

from mmtbx.chemical_components import generate_chemical_components_codes
from mmtbx.chemical_components import get_cif_dictionary

from elbow.formats.protein_sequence_setup import protein_sequence_to_three
from elbow.utilities.Utilities import get_elbow_molecule_from_chemical_components
from elbow.scripts.process_non_standard_aminoacids import \
  non_standard_amino_acid_types, non_standard_rna_dna_types, terminii, saccharide
from elbow.scripts.process_non_standard_aminoacids import \
  non_standard_rna_types, non_standard_dna_types
from elbow.scripts.process_non_standard_aminoacids import is_side_chain_addition

from cctbx.array_family import flex
from scitbx.graph import tardy_tree

skip = [
  'OGZ', # maybe wrong
  ]

rna_parents = ["A",
               'C',
               'U',
               'G',
               'T',
              ]
dna_parents = ["DA",
               "DG",
               "DU",
               "DC",
               'DT',
               'DI',
              ]
rna_dna_parents = rna_parents + dna_parents

d_peptide_parents = {
  'DCY' : 'CYS',
  'DSN' : 'SER',
  'DTH' : 'THR',
}

glyco_parents = ['FUC', 'FUL', 'SIA', 'DAN', 'XYP', 'GAL', 'GLA', 'GLC',
                 'NAG', 'NDG', 'GMH', 'MAN', 'BGC', 'RIB', 'GZL', 'YYK',
                 'GCS', 'PA1', 'Z6H', '95Z', 'RAM', 'NGA', 'FRU', 'AFD',
                 'BXX', 'BXY', 'Z9N', 'SEJ', 'BM3', 'BDP', 'PSV', 'KDO',
                 'A2G', 'RAE', 'BDF', 'SLB', 'GCU', 'BM7', 'Z0F', 'ZEE',
                 'IDR', '3MK', 'LGU', 'AHR', 'GXL', 'ARA', 'BMA', '289',
                 'ADA', 'MUR', 'SDY', 'FCB', 'G6D', 'BDR', 'SHD', 'XYS',
                 ]
nucliotide_parents = ['ADN']
non_polymer_parents = ['NPS', 'PUT', 'PEE']

def as_cpp(tree, amino_acid=True):
  amino_acid_str = 'rna dna'.upper().replace(' ', '/')
  if amino_acid: amino_acid_str = 'amino acid'
  outl = '''/*
This file contains all residue names for modified %ss.
This file is generated by the following procedure:

  phenix.python elbow/elbow/scripts/process_amino_acid_parentage_from_chemical_componts.py

This file is intended to be generated monthly.
The date of file generation: %s
*/

#include <string>
#include <set>

namespace iotbx { namespace pdb { namespace common_residue_names {

  static const char* modified_%s[] = {
''' % (amino_acid_str,
       time.asctime(),
       amino_acid_str.lower().replace(' ', '_').replace('/', '_'),
       )
  for standard, item in sorted(tree.items()):
    for i, nons in enumerate(item):
      outl += '    "%s",' % nons
      if i: outl += '\n'
      else: outl += ' // parent is %s\n' % standard
  outl += '''    0
  };


}}} // namespace iotbx::pdb::common_residue_names
'''
  return outl

def as_dict_to_single_letter(tree, amino_acid=True):
  amino_acid_str = 'rna dna'.upper().replace(' ', '/')
  if amino_acid: amino_acid_str = 'amino acid'
  outl = '''
"""
This file contains all residue names for modified %ss linked to their
one letter standard parent %s.  This file is generated by the following
procedure:

  phenix.python elbow/elbow/scripts/process_amino_acid_parentage_from_chemical_componts.py

This file is intended to be generated monthly.
The date of file generation: %s
"""
from __future__ import absolute_import, division, print_function

lookup = {
''' % (amino_acid_str, amino_acid_str, time.asctime())
  for three in sorted(tree):
    if amino_acid:
      for one, lookup in protein_sequence_to_three.items():
        if three=='?':
          one='?'
          break
        if three==lookup: break
      else:
        print('parent %(three)s not found' % locals())
        print(protein_sequence_to_three)
        assert 0
    else:
      one = three
      assert one in rna_dna_parents+['?'], '%(three)s' % locals()
    for ns in tree[three]:
      outl += '  "%(ns)s" : "%(one)s",\n' % locals()
  outl += '''}
if __name__ == '__main__':
  print(len(lookup.keys()))
'''
  return outl

def compare_etities(tree):
  def get_tardy_tree(mol):
    sites_cart = flex.vec3_double()
    for atom in mol:
      sites_cart.append(atom.xyz)
    edge_list = []
    for bond in mol.bonds:
      edge = [bond[0].index-1, bond[1].index-1]
      edge.sort()
      edge_list.append(edge)
    tt = tardy_tree.construct(sites=sites_cart,
                              edge_list=edge_list,
      )
    return tt

  new_tree = {}
  not_side_chains = {}
  for parent, item in tree.items():
    mol1 = get_elbow_molecule_from_chemical_components(parent)
    mol1.RemoveHydrogens()
    mol1.ReIndex()
    print(mol1.DisplayBrief())
    tt1 = get_tardy_tree(mol1)
    for code in item:
      if not is_side_chain_addition(code):
        print(parent, code)
        not_side_chains.setdefault(parent, [])
        not_side_chains[parent].append(code)
        continue
      mol2 = get_elbow_molecule_from_chemical_components(code)
      mol2.RemoveHydrogens()
      mol2.ReIndex()
      print(mol2.DisplayBrief())
      #if len(mol2)>len(mol1)+3: continue
      tt2 = get_tardy_tree(mol2)
      if len(tt1.cluster_manager.hinge_edges)!=len(tt2.cluster_manager.hinge_edges):
        pass
      else:
        print(parent, mol1.DisplayVeryBrief())
        print(tt1.cluster_manager.hinge_edges)
        print(code, mol2.DisplayVeryBrief())
        print(tt2.cluster_manager.hinge_edges)
        #if tt1.cluster_manager.hinge_edges==tt2.cluster_manager.hinge_edges:
        #  assert 0
        new_tree.setdefault(parent, [])
        new_tree[parent].append(code)

  print(new_tree)
  print()
  for parent, item in new_tree.items():
    for code in item:
      cmd = "phenix.reel --chem %s &;phenix.reel --chem %s" % (parent, code)
      print(cmd)
  print()
  for parent, item in not_side_chains.items():
    for code in item:
      cmd = "phenix.reel --chem %s &;phenix.reel --chem %s" % (parent, code)
      print(cmd)

def is_polymer(t):
  if t.upper() in ['NON-POLYMER']: return False
  if t.upper() in non_standard_amino_acid_types: return True, 0
  if t.upper() in non_standard_rna_types: return True, 1
  if t.upper() in non_standard_dna_types: return True, 2
  if t.upper() in terminii: return True, 3
  if t.upper() in saccharide: return True, 4
  if t.upper() in ['D-beta-peptide, C-gamma linking'.upper(), # ACB
                   'D-gamma-peptide, C-delta linking'.upper(), # FGA
                   'L-gamma-peptide, C-delta linking'.upper(), # GGL
                   'L-beta-peptide, C-gamma linking'.upper(), # IAS
                  ]: return True, 0
  print('|%s|' % t)
  assert 0

def poly_type_details(poly_type):
  ip = is_polymer(poly_type)
  if ip is False:
    return '?'
  else:
    assert ip[0]
    key=['AA', 'RNA', 'DNA', 'TERM', 'GLYCO', 'OTHER'][ip[1]]
    return key

def is_d_peptide(t):
  if t.upper().find('D-PEPTIDE')>-1: return True
  return False

def get_d_peptide_parent(t, verbose=False):
  three = d_peptide_parents.get(t, None)
  if three: return three
  for one, three in protein_sequence_to_three.items():
    if three.find(t[1:])==0:
      print("D-PEPTIDE  '%s' : '%s'" % (t, three))
      return three
    if t==three: return three
  assert 0

def get_parent_from_comma_list(parent):
  aa_hierarchy = {
    ('ALA', 'GLY', 'SER') : 'SER',
    }
  rc = parent.replace(' ','')
  rc = rc.upper()
  rc = rc.split(',')
  rc = sorted(rc)
  rc =tuple(rc)
  print(parent, rc)
  parent = None
  if rc in aa_hierarchy:
    parent = aa_hierarchy[rc]
  return parent

class parented(dict):
  def append(self, parent, code, poly_type=None, chem_comp=None):
    def _append(key):
      self.setdefault(key, {})
      self[key].setdefault(parent, [])
      self[key][parent].append(code)
    if parent.upper() in protein_sequence_to_three.values():
      _append('AA')
    elif parent.upper() in dna_parents:
      _append('DNA')
    elif parent.upper() in rna_parents:
      _append('RNA')
    elif parent in ['?', '"ISO-GALACTO-FAGOMINE LACTAM"']:
      key = poly_type_details(poly_type)
      _append(key)
    elif parent.find(',')>-1:
      _append('Multiple')
    else:
      if parent in d_peptide_parents:
        _append('D-PEPTIDE')
      elif parent in glyco_parents:
        _append('GLYCO')
      elif parent in nucliotide_parents:
        _append('NUCLIOTIDE')
      elif parent in non_polymer_parents:
        _append('NON-POLYMER')
      else:
        # self.show()
        print(' failed to append parent %s for code %s' % (parent, code))
        print(chem_comp)
        keys = OrderedDict()
        keys['GLYCO'] = glyco_parents
        keys['NUCLIOTIDE'] = nucliotide_parents
        keys['NON-POLYMER'] = non_polymer_parents
        keys['ERROR'] = []
        for i, key in enumerate(keys):
          print(i,key,keys[key][:10])
        rc = raw_input(' choose type ~> ')
        rc = int(rc)
        rc = keys.keys()[rc]
        if rc:
          gp = keys.get(rc, None)
          if gp == []:
            _append('NON-POLYMER')
          if gp is not None:
            gp.append(parent)
            print('NEW'*10)
            print(gp)
        else:
          assert 0

  def show(self):
    for key, item in self.items():
      print(key)
      for parent, child in sorted(item.items()):
        print('  %s : %4d - %s' % (parent, len(child), child[:10]))

def run(only_code=None, start_letter=None):
  if only_code in ['none']: only_code=None
  tree_aa = {}
  tree_rna = {}
  tree_dna = {}
  tree_glyco = {}
  questions = []
  parents = parented()
  for i, code in enumerate(sorted(generate_chemical_components_codes())):
    if only_code is not None and code!=only_code.upper(): continue
    if start_letter is not None and code.find(start_letter.upper())!=0: continue
    if start_letter or only_code:
      print(i,code)
    if code.upper() in skip:
      print('skipping code %s' % code)
      if only_code: assert 0
      continue
    #
    # skip if standard amino acid or nucleotide
    #
    if code in protein_sequence_to_three.values(): continue
    if code in ['G', 'C', 'T', 'A', 'U']: continue
    if i%100==0 or only_code:
      print('Code %5s %s' % (i,code))
    cif = get_cif_dictionary(code)
    if cif is None:
      print('  CIF from %(code)s %(cif)s' % locals())
    chem_comp = cif.get("_chem_comp", None)
    if only_code: print('chem_comp',chem_comp)
    if chem_comp is None:
      if only_code: assert 0
      continue
    #
    parent = getattr(chem_comp[0], "mon_nstd_parent_comp_id", None)
    if only_code: print('  parent of %(code)s is %(parent)s' % locals())
    poly_type = getattr(chem_comp[0], 'type', None)
    if only_code: print('  poly_type of %(code)s is %(poly_type)s' % locals())
    if parent.find(",")>-1:
      print('    Multiple parent',parent,code)
      # cmd = 'phenix.reel --chem %s' % code
      # os.system(cmd)
      rc = get_parent_from_comma_list(parent)
      if rc:
        parent = rc
      else:
        print('WARNING '*10)
        if only_code: assert 0
        continue
    parents.append(parent, code, poly_type=poly_type, chem_comp=chem_comp)
    if parent.find(",")>-1:
      print('    Multiple parent',parent,code)
      if only_code: assert 0
      continue
    #
    if poly_type.find(',')>-1:
      assert only_code is None
      continue
    #
    if parent is None: # or parent=="?":
      if poly_type in saccharide:
        tree_glyco.setdefault('uncommon', [])
        tree_glyco['uncommon'].append(code)
      elif poly_type in non_standard_amino_acid_types:
        questions.append(code)
        #assert len(questions)<10, 'questions %s' % questions
      continue
    #
    polymer = is_polymer(poly_type)
    if not polymer:
      if only_code: print('  NON-POLYMER',code)
      # assert only_code is None
      continue

    if parent in glyco_parents:
      if only_code: print('Glyco parent',i,code,parent)
      assert only_code is None
      continue

    # code has a parent
    if parent in rna_parents or poly_type_details(poly_type)=='RNA':
      tree_rna.setdefault(parent, [])
      tree_rna[parent].append(code)
      # print('-'*80)
      # print(code,parent,poly_type_details(poly_type))
      # print(tree_rna)
      # print('-'*80)
      # assert only_code is None
      continue
    if parent in dna_parents or poly_type_details(poly_type)=='DNA':
      tree_dna.setdefault(parent, [])
      tree_dna[parent].append(code)
      # print('-'*80)
      # print(code,parent,poly_type_details(poly_type))
      # print(tree_dna)
      # print('-'*80)
      # assert only_code is None
      continue

    if parent=='?':
      ip = poly_type_details(poly_type)
      # print(code, parent, poly_type, ip)
      if ip in ['GLYCO', 'TERM']: continue
      if ip not in ['AA']:
        assert 0
    elif is_d_peptide(poly_type):
      #
      # this may not be best as D-peptides may not be being added. Need example.
      #
      parent = get_d_peptide_parent(parent)

    parent = parent.upper() # 5GG -> Lys

    assert len(parent)<4, 'code %(code)s -> %(parent)s' % locals()
    assert parent==parent.upper(), 'code %(code)s -> %(parent)s' % locals()
    # assert parent in glyco_parents, 'code %(code)s -> %(parent)s' % locals()
    assert parent in protein_sequence_to_three.values() + ['?'], '%s %s' % (code, parent)

    tree_aa.setdefault(parent, [])
    tree_aa[parent].append(code)

  if 0:
    print('tree_glyco')
    print(tree_glyco)
    print(tree_aa)
    print(tree_rna)
    print(tree_dna)
    for key in ['?']:
      try: del tree_aa[key]
      except: pass
      try: del tree_glyco[key]
      except: pass
      try: del tree_rna[key]
      except: pass
      try: del tree_dna[key]
      except: pass

  print(questions)
  print(len(questions))
  print('='*80)
  parents.show()
  print('='*80)

  if only_code:
    print(tree_aa)
    print(tree_rna)
    print(tree_dna)

  def print_guts(s):
    print('_'*80)
    if s.find('namespace')>-1:
      print(s[s.find('static const')-2:s.find('};')+2])
    else:
      print(s[s.find('lookup'):s.find('}')+1])
    print('_'*80)

  outl = as_cpp(tree_aa)
  if only_code or start_letter: print(print_guts(outl))
  f = open('modified_aa_names.h', 'w')
  f.write(outl)
  del f

  outl = as_dict_to_single_letter(tree_aa)
  if only_code or start_letter: print(print_guts(outl))
  f = open('modified_aa_names.py', 'w')
  f.write(outl)
  del f

  if 1: # currently RNA and DNA are in the same bunch

    # tree_rna.update(tree_dna)
    for key, item in tree_dna.items():
      if key in tree_rna:
        tree_rna[key]+=item
      else:
        tree_rna[key]=item

    outl = as_cpp(tree_rna, amino_acid=False)
    if only_code or start_letter: print(print_guts(outl))
    f = open('modified_rna_dna_names.h', 'w')
    f.write(outl)
    del f

    outl = as_dict_to_single_letter(tree_rna, amino_acid=False)
    if only_code or start_letter: print(print_guts(outl))
    f = open('modified_rna_dna_names.py', 'w')
    f.write(outl)
    del f

  else:

    print(tree_rna)

    outl = as_cpp(tree_rna, amino_acid=False)
    print(print_guts(outl))
    f = open('modified_rna_names.h', 'w')
    f.write(outl)
    del f

    outl = as_dict_to_single_letter(tree_rna, amino_acid=False)
    print(print_guts(outl))
    f = open('modified_rna_names.py', 'w')
    f.write(outl)
    del f

    print(tree_dna)

    outl = as_cpp(tree_dna, amino_acid=False)
    print(outl[:1000])
    f = open('modified_dna_names.h', 'w')
    f.write(outl)
    del f

    outl = as_dict_to_single_letter(tree_dna, amino_acid=False)
    print(outl[:1000])
    f = open('modified_dna_names.py', 'w')
    f.write(outl)
    del f

if __name__=="__main__":
  run(*tuple(sys.argv[1:]))
